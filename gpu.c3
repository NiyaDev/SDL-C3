
module sdl3;

// Types
alias GPUBuffer = void;
alias GPUCommandBuffer = void;
alias GPUComputePass = void;
alias GPUCopyPass = void;
alias GPUDevice = void;
alias GPUFence = void;
alias GPUGraphicsPipeline = void;
alias GPURenderPass = void;
alias GPUSampler = void;
alias GPUShader = void;
alias GPUTexture = void;
alias GPUTransferBuffer = void;

// Bitstructs
bitstruct GPUBufferUsage : uint {
  bool vertex;
  bool index;
  bool indirect;
  bool graphicsStorageRead;
  bool computeStorageRead;
  bool computeStorageWrite;
}
bitstruct GPUColorComponentFlags : char {
  bool r;
  bool g;
  bool b;
  bool a;
}
bitstruct GPUShaderFormat : uint {
  bool private;
  bool spirv;
  bool dxbc;
  bool dxil;
  bool msl;
  bool metallib;
}
bitstruct GPUTextureUsageFlags : uint {
  bool sampler;
  bool colorTarget;
  bool depthStencilTarget;
  bool graphicsStorageRead;
  bool computeStorageRead;
  bool computeStorageWrite;
  bool computeStorageSimultaneousReadWrite;
}

// Structs
struct GPUBlitInfo {
  GPUBlitRegion source;       /**< The source region for the blit. */
  GPUBlitRegion destination;  /**< The destination region for the blit. */
  GPULoadOp load_op;          /**< What is done with the contents of the destination before the blit. */
  FColor clear_color;         /**< The color to clear the destination region to before the blit. Ignored if load_op is not SDL_GPU_LOADOP_CLEAR. */
  FlipMode flip_mode;         /**< The flip mode for the source region. */
  GPUFilter filter;           /**< The filter mode used when blitting. */
  bool cycle;                 /**< true cycles the destination texture if it is already bound. */
  char padding1, padding2, padding3;
}
struct GPUBlitRegion {
  GPUTexture *texture;        /**< The texture. */
  uint mip_level;             /**< The mip level index of the region. */
  uint layer_or_depth_plane;  /**< The layer index or depth plane of the region. This value is treated as a layer index on 2D array and cube textures, and as a depth plane on 3D textures. */
  uint x;                     /**< The left offset of the region. */
  uint y;                     /**< The top offset of the region.  */
  uint w;                     /**< The width of the region. */
  uint h;                     /**< The height of the region. */
}
struct GPUBufferBinding {
  GPUBuffer* buffer;  /**< The buffer to bind. Must have been created with SDL_GPU_BUFFERUSAGE_VERTEX for SDL_BindGPUVertexBuffers, or SDL_GPU_BUFFERUSAGE_INDEX for SDL_BindGPUIndexBuffer. */
  uint offset;        /**< The starting byte of the data to bind in the buffer. */
}
struct GPUBufferCreateInfo {
  GPUBufferUsageFlags usage;  /**< How the buffer is intended to be used by the client. */
  uint size;                  /**< The size in bytes of the buffer. */

  PropertiesID props;         /**< A properties ID for extensions. Should be 0 if no extensions are needed. */
}
struct GPUBufferLocation {
  GPUBuffer *buffer;  /**< The buffer. */
  uint offset;        /**< The starting byte within the buffer. */
}
struct GPUBufferRegion {
  GPUBuffer *buffer;  /**< The buffer. */
  uint offset;        /**< The starting byte within the buffer. */
  uint size;          /**< The size in bytes of the region. */
}
struct GPUColorTargetBlendState {
  GPUBlendFactor src_color_blendfactor;     /**< The value to be multiplied by the source RGB value. */
  GPUBlendFactor dst_color_blendfactor;     /**< The value to be multiplied by the destination RGB value. */
  GPUBlendOp color_blend_op;                /**< The blend operation for the RGB components. */
  GPUBlendFactor src_alpha_blendfactor;     /**< The value to be multiplied by the source alpha. */
  GPUBlendFactor dst_alpha_blendfactor;     /**< The value to be multiplied by the destination alpha. */
  GPUBlendOp alpha_blend_op;                /**< The blend operation for the alpha component. */
  GPUColorComponentFlags color_write_mask;  /**< A bitmask specifying which of the RGBA components are enabled for writing. Writes to all channels if enable_color_write_mask is false. */
  bool enable_blend;                        /**< Whether blending is enabled for the color target. */
  bool enable_color_write_mask;             /**< Whether the color write mask is enabled. */
  char padding1, padding2;
}
struct GPUColorTargetDescription {
  GPUTextureFormat format;               /**< The pixel format of the texture to be used as a color target. */
  GPUColorTargetBlendState blend_state;  /**< The blend state to be used for the color target. */
}
struct GPUColorTargetInfo {
  GPUTexture *texture;         /**< The texture that will be used as a color target by a render pass. */
  uint mip_level;                /**< The mip level to use as a color target. */
  uint layer_or_depth_plane;     /**< The layer index or depth plane to use as a color target. This value is treated as a layer index on 2D array and cube textures, and as a depth plane on 3D textures. */
  FColor clear_color;          /**< The color to clear the color target to at the start of the render pass. Ignored if SDL_GPU_LOADOP_CLEAR is not used. */
  GPULoadOp load_op;           /**< What is done with the contents of the color target at the beginning of the render pass. */
  GPUStoreOp store_op;         /**< What is done with the results of the render pass. */
  GPUTexture *resolve_texture; /**< The texture that will receive the results of a multisample resolve operation. Ignored if a RESOLVE* store_op is not used. */
  uint resolve_mip_level;        /**< The mip level of the resolve texture to use for the resolve operation. Ignored if a RESOLVE* store_op is not used. */
  uint resolve_layer;            /**< The layer index of the resolve texture to use for the resolve operation. Ignored if a RESOLVE* store_op is not used. */
  bool cycle;                      /**< true cycles the texture if the texture is bound and load_op is not LOAD */
  bool cycle_resolve_texture;      /**< true cycles the resolve texture if the resolve texture is bound. Ignored if a RESOLVE* store_op is not used. */
  char padding1, padding2;
}
struct GPUComputePipelineCreateInfo {
  usz code_size;                        /**< The size in bytes of the compute shader code pointed to. */
  char* code;                           /**< A pointer to compute shader code. */
  char* entrypoint;                     /**< A pointer to a null-terminated UTF-8 string specifying the entry point function name for the shader. */
  GPUShaderFormat format;               /**< The format of the compute shader code. */
  uint num_samplers;                    /**< The number of samplers defined in the shader. */
  uint num_readonly_storage_textures;   /**< The number of readonly storage textures defined in the shader. */
  uint num_readonly_storage_buffers;    /**< The number of readonly storage buffers defined in the shader. */
  uint num_readwrite_storage_textures;  /**< The number of read-write storage textures defined in the shader. */
  uint num_readwrite_storage_buffers;   /**< The number of read-write storage buffers defined in the shader. */
  uint num_uniform_buffers;             /**< The number of uniform buffers defined in the shader. */
  uint threadcount_x;                   /**< The number of threads in the X dimension. This should match the value in the shader. */
  uint threadcount_y;                   /**< The number of threads in the Y dimension. This should match the value in the shader. */
  uint threadcount_z;                   /**< The number of threads in the Z dimension. This should match the value in the shader. */

  PropertiesID props;                   /**< A properties ID for extensions. Should be 0 if no extensions are needed. */
}
struct GPUDepthStencilState {
  GPUCompareOp compare_op;                /**< The comparison operator used for depth testing. */
  GPUStencilOpState back_stencil_state;   /**< The stencil op state for back-facing triangles. */
  GPUStencilOpState front_stencil_state;  /**< The stencil op state for front-facing triangles. */
  char compare_mask;                      /**< Selects the bits of the stencil values participating in the stencil test. */
  char write_mask;                        /**< Selects the bits of the stencil values updated by the stencil test. */
  bool enable_depth_test;                 /**< true enables the depth test. */
  bool enable_depth_write;                /**< true enables depth writes. Depth writes are always disabled when enable_depth_test is false. */
  bool enable_stencil_test;               /**< true enables the stencil test. */
  char padding1, padding2, padding3;
}
struct GPUDepthStencilTargetInfo {
  GPUTexture *texture;               /**< The texture that will be used as the depth stencil target by the render pass. */
  float clear_depth;                 /**< The value to clear the depth component to at the beginning of the render pass. Ignored if SDL_GPU_LOADOP_CLEAR is not used. */
  GPULoadOp load_op;                 /**< What is done with the depth contents at the beginning of the render pass. */
  GPUStoreOp store_op;               /**< What is done with the depth results of the render pass. */
  GPULoadOp stencil_load_op;         /**< What is done with the stencil contents at the beginning of the render pass. */
  GPUStoreOp stencil_store_op;       /**< What is done with the stencil results of the render pass. */
  bool cycle;                        /**< true cycles the texture if the texture is bound and any load ops are not LOAD */
  char clear_stencil;                /**< The value to clear the stencil component to at the beginning of the render pass. Ignored if SDL_GPU_LOADOP_CLEAR is not used. */
  char mip_level;                    /**< The mip level to use as the depth stencil target. */
  char layer;                        /**< The layer index to use as the depth stencil target. */
}
struct GPUGraphicsPipelineCreateInfo {
  GPUShader* vertex_shader;                   /**< The vertex shader used by the graphics pipeline. */
  GPUShader* fragment_shader;                 /**< The fragment shader used by the graphics pipeline. */
  GPUVertexInputState vertex_input_state;     /**< The vertex layout of the graphics pipeline. */
  GPUPrimitiveType primitive_type;            /**< The primitive topology of the graphics pipeline. */
  GPURasterizerState rasterizer_state;        /**< The rasterizer state of the graphics pipeline. */
  GPUMultisampleState multisample_state;      /**< The multisample state of the graphics pipeline. */
  GPUDepthStencilState depth_stencil_state;   /**< The depth-stencil state of the graphics pipeline. */
  GPUGraphicsPipelineTargetInfo target_info;  /**< Formats and blend modes for the render targets of the graphics pipeline. */

  PropertiesID props;                         /**< A properties ID for extensions. Should be 0 if no extensions are needed. */
}
struct GPUGraphicsPipelineTargetInfo {
  GPUColorTargetDescription *color_target_descriptions;  /**< A pointer to an array of color target descriptions. */
  uint num_color_targets;                                /**< The number of color target descriptions in the above array. */
  GPUTextureFormat depth_stencil_format;                 /**< The pixel format of the depth-stencil target. Ignored if has_depth_stencil_target is false. */
  bool has_depth_stencil_target;                         /**< true specifies that the pipeline uses a depth-stencil target. */
  char padding1, padding2, padding3;
}
struct GPUIndexedIndirectDrawCommand {
  uint num_indices;    /**< The number of indices to draw per instance. */
  uint num_instances;  /**< The number of instances to draw. */
  uint first_index;    /**< The base index within the index buffer. */
  uint vertex_offset;  /**< The value added to the vertex index before indexing into the vertex buffer. */
  uint first_instance; /**< The ID of the first instance to draw. */
}
struct GPUIndirectDispatchCommand {
  uint groupcount_x;  /**< The number of local workgroups to dispatch in the X dimension. */
  uint groupcount_y;  /**< The number of local workgroups to dispatch in the Y dimension. */
  uint groupcount_z;  /**< The number of local workgroups to dispatch in the Z dimension. */
}
struct GPUIndirectDrawCommand {
  uint num_vertices;   /**< The number of vertices to draw. */
  uint num_instances;  /**< The number of instances to draw. */
  uint first_vertex;   /**< The index of the first vertex to draw. */
  uint first_instance; /**< The ID of the first instance to draw. */
}
struct GPUMultisampleState {
  GPUSampleCount sample_count;      /**< The number of samples to be used in rasterization. */
  uint sample_mask;                 /**< Reserved for future use. Must be set to 0. */
  bool enable_mask;                 /**< Reserved for future use. Must be set to false. */
  bool enable_alpha_to_coverage;    /**< true enables the alpha-to-coverage feature. */
  char padding2, padding3;
}
struct GPURasterizerState {
  GPUFillMode fill_mode;             /**< Whether polygons will be filled in or drawn as lines. */
  GPUCullMode cull_mode;             /**< The facing direction in which triangles will be culled. */
  GPUFrontFace front_face;            /**< The vertex winding that will cause a triangle to be determined as front-facing. */
  float depth_bias_constant_factor;  /**< A scalar factor controlling the depth value added to each fragment. */
  float depth_bias_clamp;            /**< The maximum depth bias of a fragment. */
  float depth_bias_slope_factor;     /**< A scalar factor applied to a fragment's slope in depth calculations. */
  bool enable_depth_bias;            /**< true to bias fragment depth values. */
  bool enable_depth_clip;            /**< true to enable depth clip, false to enable depth clamp. */
  char padding1, padding2;
}
struct GPUSamplerCreateInfo {
  GPUFilter min_filter;                  /**< The minification filter to apply to lookups. */
  GPUFilter mag_filter;                  /**< The magnification filter to apply to lookups. */
  GPUSamplerMipmapMode mipmap_mode;      /**< The mipmap filter to apply to lookups. */
  GPUSamplerAddressMode address_mode_u;  /**< The addressing mode for U coordinates outside [0, 1). */
  GPUSamplerAddressMode address_mode_v;  /**< The addressing mode for V coordinates outside [0, 1). */
  GPUSamplerAddressMode address_mode_w;  /**< The addressing mode for W coordinates outside [0, 1). */
  float mip_lod_bias;                    /**< The bias to be added to mipmap LOD calculation. */
  float max_anisotropy;                  /**< The anisotropy value clamp used by the sampler. If enable_anisotropy is false, this is ignored. */
  GPUCompareOp compare_op;               /**< The comparison operator to apply to fetched data before filtering. */
  float min_lod;                         /**< Clamps the minimum of the computed LOD value. */
  float max_lod;                         /**< Clamps the maximum of the computed LOD value. */
  bool enable_anisotropy;                /**< true to enable anisotropic filtering. */
  bool enable_compare;                   /**< true to enable comparison against a reference value during lookups. */
  char padding1, padding2;

  PropertiesID props;                    /**< A properties ID for extensions. Should be 0 if no extensions are needed. */
}
struct GPUShaderCreateInfo {
  usz code_size;              /**< The size in bytes of the code pointed to. */
  char* code;                 /**< A pointer to shader code. */
  char* entrypoint;           /**< A pointer to a null-terminated UTF-8 string specifying the entry point function name for the shader. */
  GPUShaderFormat format;     /**< The format of the shader code. */
  GPUShaderStage stage;       /**< The stage the shader program corresponds to. */
  uint num_samplers;          /**< The number of samplers defined in the shader. */
  uint num_storage_textures;  /**< The number of storage textures defined in the shader. */
  uint num_storage_buffers;   /**< The number of storage buffers defined in the shader. */
  uint num_uniform_buffers;   /**< The number of uniform buffers defined in the shader. */

  PropertiesID props;         /**< A properties ID for extensions. Should be 0 if no extensions are needed. */
}
struct GPUStencilOpState {
  GPUStencilOp fail_op;        /**< The action performed on samples that fail the stencil test. */
  GPUStencilOp pass_op;        /**< The action performed on samples that pass the depth and stencil tests. */
  GPUStencilOp depth_fail_op;  /**< The action performed on samples that pass the stencil test and fail the depth test. */
  GPUCompareOp compare_op;     /**< The comparison operator used in the stencil test. */
}
struct GPUStorageBufferReadWriteBinding {
  GPUBuffer *buffer;  /**< The buffer to bind. Must have been created with SDL_GPU_BUFFERUSAGE_COMPUTE_STORAGE_WRITE. */
  bool cycle;         /**< true cycles the buffer if it is already bound. */
  char padding1, padding2, padding3;
}
struct GPUStorageTextureReadWriteBinding {
  GPUTexture *texture;  /**< The texture to bind. Must have been created with SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_WRITE or SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE. */
  uint mip_level;       /**< The mip level index to bind. */
  uint layer;           /**< The layer index to bind. */
  bool cycle;           /**< true cycles the texture if it is already bound. */
  char padding1, padding2, padding3;
}
struct GPUTextureCreateInfo {
  GPUTextureType type;          /**< The base dimensionality of the texture. */
  GPUTextureFormat format;      /**< The pixel format of the texture. */
  GPUTextureUsageFlags usage;   /**< How the texture is intended to be used by the client. */
  uint width;                   /**< The width of the texture. */
  uint height;                  /**< The height of the texture. */
  uint layer_count_or_depth;    /**< The layer count or depth of the texture. This value is treated as a layer count on 2D array textures, and as a depth value on 3D textures. */
  uint num_levels;              /**< The number of mip levels in the texture. */
  GPUSampleCount sample_count;  /**< The number of samples per texel. Only applies if the texture is used as a render target. */

  PropertiesID props;           /**< A properties ID for extensions. Should be 0 if no extensions are needed. */
}
struct GPUTextureLocation {
  GPUTexture* texture;    /**< The texture used in the copy operation. */
  uint mip_level;         /**< The mip level index of the location. */
  uint layer;             /**< The layer index of the location. */
  uint x;                 /**< The left offset of the location. */
  uint y;                 /**< The top offset of the location. */
  uint z;                 /**< The front offset of the location. */
}
struct GPUTextureRegion {
  GPUTexture* texture;  /**< The texture used in the copy operation. */
  uint mip_level;         /**< The mip level index to transfer. */
  uint layer;             /**< The layer index to transfer. */
  uint x;                 /**< The left offset of the region. */
  uint y;                 /**< The top offset of the region. */
  uint z;                 /**< The front offset of the region. */
  uint w;                 /**< The width of the region. */
  uint h;                 /**< The height of the region. */
  uint d;                 /**< The depth of the region. */
}
struct GPUTextureSamplerBinding {
  GPUTexture* texture;  /**< The texture to bind. Must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER. */
  GPUSampler* sampler;  /**< The sampler to bind. */
}
struct GPUTextureTransferInfo {
  GPUTransferBuffer* transfer_buffer;  /**< The transfer buffer used in the transfer operation. */
  uint offset;                           /**< The starting byte of the image data in the transfer buffer. */
  uint pixels_per_row;                   /**< The number of pixels from one row to the next. */
  uint rows_per_layer;                   /**< The number of rows from one layer/depth-slice to the next. */
}
struct GPUTransferBufferCreateInfo {
  GPUTransferBufferUsage usage;  /**< How the transfer buffer is intended to be used by the client. */
  uint size;                     /**< The size in bytes of the transfer buffer. */

  PropertiesID props;            /**< A properties ID for extensions. Should be 0 if no extensions are needed. */
}
struct GPUTransferBufferLocation {
  GPUTransferBuffer* transfer_buffer;  /**< The transfer buffer used in the transfer operation. */
  uint offset;                           /**< The starting byte of the buffer data in the transfer buffer. */
}
struct GPUVertexAttribute {
  uint location;                  /**< The shader input location index. */
  uint buffer_slot;               /**< The binding slot of the associated vertex buffer. */
  GPUVertexElementFormat format;  /**< The size and type of the attribute data. */
  uint offset;                    /**< The byte offset of this attribute relative to the start of the vertex element. */
}
struct GPUVertexBufferDescription {
  uint slot;                      /**< The binding slot of the vertex buffer. */
  uint pitch;                     /**< The size of a single element + the offset between elements. */
  GPUVertexInputRate input_rate;  /**< Whether attribute addressing is a function of the vertex index or instance index. */
  uint instance_step_rate;        /**< Reserved for future use. Must be set to 0. */
}
struct GPUVertexInputState {
  GPUVertexBufferDescription *vertex_buffer_descriptions; /**< A pointer to an array of vertex buffer descriptions. */
  uint num_vertex_buffers;                                /**< The number of vertex buffer descriptions in the above array. */
  GPUVertexAttribute *vertex_attributes;                  /**< A pointer to an array of vertex attribute descriptions. */
  uint num_vertex_attributes;                             /**< The number of vertex attribute descriptions in the above array. */
}
struct GPUViewport {
  float x;          /**< The left offset of the viewport. */
  float y;          /**< The top offset of the viewport. */
  float w;          /**< The width of the viewport. */
  float h;          /**< The height of the viewport. */
  float min_depth;  /**< The minimum depth of the viewport. */
  float max_depth;  /**< The maximum depth of the viewport. */
}
struct GPUVulkanOptions {
  uint vulkan_api_version;                  /**< The Vulkan API version to request for the instance. Use Vulkan's VK_MAKE_VERSION or VK_MAKE_API_VERSION. */
  void* feature_list;                       /**< Pointer to the first element of a chain of Vulkan feature structs. (Requires API version 1.1 or higher.)*/
  void* vulkan_10_physical_device_features; /**< Pointer to a VkPhysicalDeviceFeatures struct to enable additional Vulkan 1.0 features. */
  uint device_extension_count;              /**< Number of additional device extensions to require. */
  char** device_extension_names;            /**< Pointer to a list of additional device extensions to require. */
  uint instance_extension_count;            /**< Number of additional instance extensions to require. */
  char** instance_extension_names;          /**< Pointer to a list of additional instance extensions to require. */
}

// Enums
enum GPUBlendFactor {
  INVALID,
  ZERO,                      /**< 0 */
  ONE,                       /**< 1 */
  SRC_COLOR,                 /**< source color */
  ONE_MINUS_SRC_COLOR,       /**< 1 - source color */
  DST_COLOR,                 /**< destination color */
  ONE_MINUS_DST_COLOR,       /**< 1 - destination color */
  SRC_ALPHA,                 /**< source alpha */
  ONE_MINUS_SRC_ALPHA,       /**< 1 - source alpha */
  DST_ALPHA,                 /**< destination alpha */
  ONE_MINUS_DST_ALPHA,       /**< 1 - destination alpha */
  CONSTANT_COLOR,            /**< blend constant */
  ONE_MINUS_CONSTANT_COLOR,  /**< 1 - blend constant */
  SRC_ALPHA_SATURATE,        /**< min(source alpha, 1 - destination alpha) */
}
enum GPUBlendOp {
  INVALID,
  ADD,               /**< (source * source_factor) + (destination * destination_factor) */
  SUBTRACT,          /**< (source * source_factor) - (destination * destination_factor) */
  REVERSE_SUBTRACT,  /**< (destination * destination_factor) - (source * source_factor) */
  MIN,               /**< min(source, destination) */
  MAX,               /**< max(source, destination) */
}
enum GPUCompareOp {
  INVALID,
  NEVER,             /**< The comparison always evaluates false. */
  LESS,              /**< The comparison evaluates reference < test. */
  EQUAL,             /**< The comparison evaluates reference == test. */
  LESS_OR_EQUAL,     /**< The comparison evaluates reference <= test. */
  GREATER,           /**< The comparison evaluates reference > test. */
  NOT_EQUAL,         /**< The comparison evaluates reference != test. */
  GREATER_OR_EQUAL,  /**< The comparison evaluates reference >= test. */
  ALWAYS,            /**< The comparison always evaluates true. */
}
enum GPUCubeMapFace {
  POSITIVEX,
  NEGATIVEX,
  POSITIVEY,
  NEGATIVEY,
  POSITIVEZ,
  NEGATIVEZ,
}
enum GPUCullMode {
  NONE,   /**< No triangles are culled. */
  FRONT,  /**< Front-facing triangles are culled. */
  BACK,   /**< Back-facing triangles are culled. */
}
enum GPUFillMode {
  FILL,  /**< Polygons will be rendered via rasterization. */
  LINE,  /**< Polygon edges will be drawn as line segments. */
}
enum GPUFilter {
  NEAREST,  /**< Point filtering. */
  LINEAR,   /**< Linear filtering. */
}
enum GPUFrontFace {
  COUNTER_CLOCKWISE,  /**< A triangle with counter-clockwise vertex winding will be considered front-facing. */
  CLOCKWISE,          /**< A triangle with clockwise vertex winding will be considered front-facing. */
}
enum GPUIndexElementSize {
  BIT16, /**< The index elements are 16-bit. */
  BIT32, /**< The index elements are 32-bit. */
}
enum GPULoadOp {
  LOAD,      /**< The previous contents of the texture will be preserved. */
  CLEAR,     /**< The contents of the texture will be cleared to a color. */
  DONT_CARE, /**< The previous contents of the texture need not be preserved. The contents will be undefined. */
}
enum GPUPresentMode {
  VSYNC,
  IMMEDIATE,
  MAILBOX,
}
enum GPUPrimitiveType {
  TRIANGLELIST,  /**< A series of separate triangles. */
  TRIANGLESTRIP, /**< A series of connected triangles. */
  LINELIST,      /**< A series of separate lines. */
  LINESTRIP,     /**< A series of connected lines. */
  POINTLIST,     /**< A series of separate points. */
}
enum GPUSampleCount {
  S1,  /**< No multisampling. */
  S2,  /**< MSAA 2x */
  S4,  /**< MSAA 4x */
  S8,  /**< MSAA 8x */
}
enum GPUSamplerAddressMode {
  REPEAT,           /**< Specifies that the coordinates will wrap around. */
  MIRRORED_REPEAT,  /**< Specifies that the coordinates will wrap around mirrored. */
  CLAMP_TO_EDGE,    /**< Specifies that the coordinates will clamp to the 0-1 range. */
}
enum GPUSamplerMipmapMode {
  NEAREST,  /**< Point filtering. */
  LINEAR,   /**< Linear filtering. */
}
enum GPUShaderStage {
  VERTEX,
  FRAGMENT,
}
enum GPUStencilOp {
  INVALID,
  KEEP,                 /**< Keeps the current value. */
  ZERO,                 /**< Sets the value to 0. */
  REPLACE,              /**< Sets the value to reference. */
  INCREMENT_AND_CLAMP,  /**< Increments the current value and clamps to the maximum value. */
  DECREMENT_AND_CLAMP,  /**< Decrements the current value and clamps to 0. */
  INVERT,               /**< Bitwise-inverts the current value. */
  INCREMENT_AND_WRAP,   /**< Increments the current value and wraps back to 0. */
  DECREMENT_AND_WRAP,   /**< Decrements the current value and wraps to the maximum value. */
}
enum GPUStoreOp {
  STORE,             /**< The contents generated during the render pass will be written to memory. */
  DONT_CARE,         /**< The contents generated during the render pass are not needed and may be discarded. The contents will be undefined. */
  RESOLVE,           /**< The multisample contents generated during the render pass will be resolved to a non-multisample texture. The contents in the multisample texture may then be discarded and will be undefined. */
  RESOLVE_AND_STORE, /**< The multisample contents generated during the render pass will be resolved to a non-multisample texture. The contents in the multisample texture will be written to memory. */
}
enum GPUSwapchainComposition {
  SDR,
  SDR_LINEAR,
  HDR_EXTENDED_LINEAR,
  HDR10_ST2084,
}
enum GPUTextureFormat {
  INVALID,

  /* Unsigned Normalized Float Color Formats */
  A8_UNORM,
  R8_UNORM,
  R8G8_UNORM,
  R8G8B8A8_UNORM,
  R16_UNORM,
  R16G16_UNORM,
  R16G16B16A16_UNORM,
  R10G10B10A2_UNORM,
  B5G6R5_UNORM,
  B5G5R5A1_UNORM,
  B4G4R4A4_UNORM,
  B8G8R8A8_UNORM,
  /* Compressed Unsigned Normalized Float Color Formats */
  BC1_RGBA_UNORM,
  BC2_RGBA_UNORM,
  BC3_RGBA_UNORM,
  BC4_R_UNORM,
  BC5_RG_UNORM,
  BC7_RGBA_UNORM,
  /* Compressed Signed Float Color Formats */
  BC6H_RGB_FLOAT,
  /* Compressed Unsigned Float Color Formats */
  BC6H_RGB_UFLOAT,
  /* Signed Normalized Float Color Formats  */
  R8_SNORM,
  R8G8_SNORM,
  R8G8B8A8_SNORM,
  R16_SNORM,
  R16G16_SNORM,
  R16G16B16A16_SNORM,
  /* Signed Float Color Formats */
  R16_FLOAT,
  R16G16_FLOAT,
  R16G16B16A16_FLOAT,
  R32_FLOAT,
  R32G32_FLOAT,
  R32G32B32A32_FLOAT,
  /* Unsigned Float Color Formats */
  R11G11B10_UFLOAT,
  /* Unsigned Integer Color Formats */
  R8_UINT,
  R8G8_UINT,
  R8G8B8A8_UINT,
  R16_UINT,
  R16G16_UINT,
  R16G16B16A16_UINT,
  R32_UINT,
  R32G32_UINT,
  R32G32B32A32_UINT,
  /* Signed Integer Color Formats */
  R8_INT,
  R8G8_INT,
  R8G8B8A8_INT,
  R16_INT,
  R16G16_INT,
  R16G16B16A16_INT,
  R32_INT,
  R32G32_INT,
  R32G32B32A32_INT,
  /* SRGB Unsigned Normalized Color Formats */
  R8G8B8A8_UNORM_SRGB,
  B8G8R8A8_UNORM_SRGB,
  /* Compressed SRGB Unsigned Normalized Color Formats */
  BC1_RGBA_UNORM_SRGB,
  BC2_RGBA_UNORM_SRGB,
  BC3_RGBA_UNORM_SRGB,
  BC7_RGBA_UNORM_SRGB,
  /* Depth Formats */
  D16_UNORM,
  D24_UNORM,
  D32_FLOAT,
  D24_UNORM_S8_UINT,
  D32_FLOAT_S8_UINT,
  /* Compressed ASTC Normalized Float Color Formats*/
  ASTC_4X4_UNORM,
  ASTC_5X4_UNORM,
  ASTC_5X5_UNORM,
  ASTC_6X5_UNORM,
  ASTC_6X6_UNORM,
  ASTC_8X5_UNORM,
  ASTC_8X6_UNORM,
  ASTC_8X8_UNORM,
  ASTC_10X5_UNORM,
  ASTC_10X6_UNORM,
  ASTC_10X8_UNORM,
  ASTC_10X10_UNORM,
  ASTC_12X10_UNORM,
  ASTC_12X12_UNORM,
  /* Compressed SRGB ASTC Normalized Float Color Formats*/
  ASTC_4X4_UNORM_SRGB,
  ASTC_5X4_UNORM_SRGB,
  ASTC_5X5_UNORM_SRGB,
  ASTC_6X5_UNORM_SRGB,
  ASTC_6X6_UNORM_SRGB,
  ASTC_8X5_UNORM_SRGB,
  ASTC_8X6_UNORM_SRGB,
  ASTC_8X8_UNORM_SRGB,
  ASTC_10X5_UNORM_SRGB,
  ASTC_10X6_UNORM_SRGB,
  ASTC_10X8_UNORM_SRGB,
  ASTC_10X10_UNORM_SRGB,
  ASTC_12X10_UNORM_SRGB,
  ASTC_12X12_UNORM_SRGB,
  /* Compressed ASTC Signed Float Color Formats*/
  ASTC_4X4_FLOAT,
  ASTC_5X4_FLOAT,
  ASTC_5X5_FLOAT,
  ASTC_6X5_FLOAT,
  ASTC_6X6_FLOAT,
  ASTC_8X5_FLOAT,
  ASTC_8X6_FLOAT,
  ASTC_8X8_FLOAT,
  ASTC_10X5_FLOAT,
  ASTC_10X6_FLOAT,
  ASTC_10X8_FLOAT,
  ASTC_10X10_FLOAT,
  ASTC_12X10_FLOAT,
  ASTC_12X12_FLOAT,
}
enum GPUTextureType {
  T2D,         /**< The texture is a 2-dimensional image. */
  T2D_ARRAY,   /**< The texture is a 2-dimensional array image. */
  T3D,         /**< The texture is a 3-dimensional image. */
  CUBE,       /**< The texture is a cube image. */
  CUBE_ARRAY  /**< The texture is a cube array image. */
}
enum GPUTransferBufferUsage {
  UPLOAD,
  DOWNLOAD
}
enum GPUVertexElementFormat {
  INVALID,

  /* 32-bit Signed Integers */
  INT,
  INT2,
  INT3,
  INT4,

  /* 32-bit Unsigned Integers */
  UINT,
  UINT2,
  UINT3,
  UINT4,

  /* 32-bit Floats */
  FLOAT,
  FLOAT2,
  FLOAT3,
  FLOAT4,

  /* 8-bit Signed Integers */
  BYTE2,
  BYTE4,

  /* 8-bit Unsigned Integers */
  UBYTE2,
  UBYTE4,

  /* 8-bit Signed Normalized */
  BYTE2_NORM,
  BYTE4_NORM,

  /* 8-bit Unsigned Normalized */
  UBYTE2_NORM,
  UBYTE4_NORM,

  /* 16-bit Signed Integers */
  SHORT2,
  SHORT4,

  /* 16-bit Unsigned Integers */
  USHORT2,
  USHORT4,

  /* 16-bit Signed Normalized */
  SHORT2_NORM,
  SHORT4_NORM,

  /* 16-bit Unsigned Normalized */
  USHORT2_NORM,
  USHORT4_NORM,

  /* 16-bit Floats */
  HALF2,
  HALF4,
}
enum GPUVertexInputRate {
  VERTEX,   /**< Attribute addressing is a function of the vertex index. */
  INSTANCE, /**< Attribute addressing is a function of the instance index. */
}

// Functions

